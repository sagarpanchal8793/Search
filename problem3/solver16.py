#!/usr/bin/env python
# solver16.py - Solves 15 puzzle
# Created by Angad Dhillon, Sagar Panchal, Ameya Angal
#
# Abstraction:
# State: State is a List that contains following elements:
#  index 0: board (list of list)
#  index 1: list which contains moves required to get to that state
#  index 2: cost to get to that state. for each state generated by successor cost is incremented by 1
#  index 3: f(s), cost + heuristic value
#
# goal: board (list of list) [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]]
#
# successor function: This function returns a list of list, where every element is generated by moving either one or two or three tiles
#  in right, left, up or down direction. There are 6 successor to every state. I have used deepcopy to create one state from its parent.
#  On each level, cost is incremented by 1
#
# Heuristic function: Our heuristic function is
# h(s) = MD/3 + LC
# MD - manhattan distance
# LC - linear conflict
# MD needs to be divide by 3 as 3 tiles can change positions in one move. Linear conflict provides the minimum number of moves required
# to solve the conflicts in row and columns for a particular board. We have referred linear conflict algorithm from paper-
# "Generating Admissible Heuristics by Criticizing Solutions to Relaxed Models" by Othar Hansson, Andrew Mayer, and MordechaiYung.
#  This heuristic function is Consistent and Admissible.
#
# Algorithm functioning:
# 1. Check if initial state is goal state, if true return initial state
# 2. Else, add initial state to Fringe
# 3. repeat till non zero fringe
#     1. pop state with least f(s)
#     2. If state not in closed and isSolvable
#         1. Add state to Closed as it is being expanded
#         2. Check if the state is goal state, true - return state
#         3. Else, create successors for state and append to Fringe
#
# Why heuristic is admissible?
#  Our heuristic always gives the minimum possible steps to reach a goal state. If we relax the constraints and consider independent
#  tiles , MD gives least number of steps to reach goal state. Since in this problem we can move 3 tiles in one move, we are doing MD/3. We are adding this
#  to linear conflicts. Linear conflict states that if there is a conflict in a particular row/column atleast 2 moves are required to
#  resolve that conflict. In calculating the linear conflict we have considered maximum mutual conflict value in a row and column,
#  which is at minimum required to reach the goal. So MD/3+ LC is admissible.
#
# Difficulties faced:
# 1)As I have implemented linear conflict algorithm for finding LC, and the algorithm itself is computation heavy (also stated in mentioned
#  paper), running time increases. But this algorithm reduces the number of nodes expanded as it is more informed than manhattan distance.
#  I have selected a trade off between number of states in fringe vs time. As computational time for heuristic is large,
# 2)I have checked whether a state is present in closed before creating successors.  This reduced my total running time considerably as we didn't need to
#compute successors and heuristic value for successors. Also
#  I have skipped checking and replacing a state in Fringe as it was a computational heavy task, since we are removing state with least heuristic value 
# this skip will not affect optimality.
#
# references:
# 1)"Generating Admissible Heuristics by Criticizing Solutions to Relaxed Models" by Othar Hansson, Andrew Mayer, and MordechaiYung


from operator import itemgetter
import copy
import math
import time
import sys

# State: [[[],[],[],[]], [moves to get to that state], c(s),f(s)]
initial_state = []
# initial_state = [[[5,1,2,3],[13,6,4,11],[10,9,15,0],[14,12,7,8]],[], 0, 0]
goal_state = [[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]], []]
goalStatePositions = {}

# check of valid rows and col are provided
def CheckIfValidRowsAndColumn(puzzleboard):
    row = len(puzzleboard)
    if row != 4:
        return False
    for row in puzzleboard:
        col = len(row)
        if col != 4:
            return False
    return True

# check if valid tiles are present in puzzle
def CheckTilesInPuzzle(puzzleboard):
    puzzle_flat_list = [item for element in puzzleboard for item in element]
    status = all(item >= 0 or item < 16 for item in puzzle_flat_list)
    return status

# check duplicate tiles in board
def CheckDuplicateTiles(puzzleboard):
    puzzle_flat_list = [item for element in puzzleboard for item in element]
    return len(puzzle_flat_list) == len(set(puzzle_flat_list))

# creates a dictionary for evry goal state tile position
def CreateGoalStatePositionsDictionary(goal):
    for i, row in enumerate(goal):
        for j, col in enumerate(row):
            goalStatePositions[goal[i][j]] = [i, j]

# generate parity for a particular state
def GenerateParity(state):
    parityInversion = 0
    i = 0
    j = 0
    blankrow = 0
    flat_list = [item for element in state for item in element]
    for i in range(0, len(flat_list)):
        if flat_list[i] == 0:
            blankrow = math.floor(i/4)
            continue
        for j in range(i + 1, len(flat_list)):
            if flat_list[j] == 0:
                continue
            if flat_list[j] < flat_list[i]:
                parityInversion = parityInversion + 1
    return parityInversion, blankrow

# check if parity inversion is satisfied
def IsParityInversionSatisfied(currentstate):
    stateparity, blankrow = GenerateParity(currentstate)
    return (blankrow % 2) != (stateparity % 2)

# returns a position of blank tile in the given puzzle
def FindPositionOfBlankTile(puzzle):
    return [(row, col) for row in range(0, 4) for col in range(0, 4) if puzzle[row][col] == 0]

# returns the manhattan distance for the puzzle state
def ManhattanDistance(puzzle):
    manhattanDistance = 0
    for i, row in enumerate(puzzle):
        for j, col in enumerate(row):
            if col == 0:
                continue
            manhattanDistance = manhattanDistance + abs(goalStatePositions[col][0] - i) \
                                + abs(goalStatePositions[col][1] - j)
    return manhattanDistance

# returns number of conflicts in a particular row for a particular tile
def conflictsInRow(state, tile, tilerownumber, tilecolnumber):
    conflicts = 0
    row = state[tilerownumber]
    conflictedTilesInRow = []
    for k in range(0, len(row)):
        tj = tile
        tk = row[k]
        if tj != 0 and tk != 0:
            if goalStatePositions[tj][0] == goalStatePositions[tk][0]: # check if the 2 tiles are in same row in goal position
                if (tilecolnumber > k and goalStatePositions[tj][1] < goalStatePositions[tk][1]) \
                        or (tilecolnumber < k and goalStatePositions[tj][1] > goalStatePositions[tk][1]):
                    conflicts += 1
                    conflictedTilesInRow.append(tk)
    return conflicts, conflictedTilesInRow

# returns number of conflicts in a particular column for a particular tile
def conflictsInColumn(state, tile, tilerownumber, tilecolnumber):
    conflicts = 0
    conflictedTilesInColumn = []
    column = [row[tilecolnumber] for row in state]
    for k in range(0, len(column)):
        tj = tile
        tk = column[k]
        if tj != 0 and tk != 0:
            if goalStatePositions[tj][1] == goalStatePositions[tk][1]: # check if the 2 tiles are in same column in goal position
                if (tilerownumber > k and goalStatePositions[tj][0] < goalStatePositions[tk][0]) \
                        or (tilerownumber < k and goalStatePositions[tj][0] > goalStatePositions[tk][0]):
                    conflicts += 1
                    conflictedTilesInColumn.append(tk)
    return conflicts, conflictedTilesInColumn

# referred linear conflict algorithm from paper "Generating Admissible Heuristics by Criticizing Solutions to Relaxed Models" by Othar Hansson
#Andrew Mayer, and MordechaiYung
# returns linear conflict for a particular state
def linearConflict(state, lc):
    for i, row in enumerate(state):
        lc[("row", i)] = 0
        rConflicts = {}
        for j, col in enumerate(row):
            rConflicts[(state[i][j], i)] = conflictsInRow(state, state[i][j], i, j)
        while max(rConflicts.iteritems(), key = lambda x: x[1][0])[1][0] > 0:
            keytk = max(rConflicts.iteritems(), key = itemgetter(1))[0]
            conflictedTilesWithtk = rConflicts[keytk][1]
            rConflicts[keytk] = [0, conflictedTilesWithtk]
            for tj in rConflicts[keytk][1]:
                rConflicts[(tj, i)] = rConflicts[(tj, i)][0] - 1, rConflicts[(tj, i)][1]
            lc[("row", i)] = lc[("row", i)] + 1

    for k in range(0, len(state[0])):
        lc[("col", k)] = 0
        cConflicts = {}
        for i, row in enumerate(state):
            cConflicts[(state[i][k], k)] = conflictsInColumn(state, state[i][k], i, k)
        while max(cConflicts.iteritems(), key=lambda x: x[1][0])[1][0] > 0:
            keytk = max(cConflicts.iteritems(), key=itemgetter(1))[0]
            conflictedTilesWithtk = cConflicts[keytk][1]
            cConflicts[keytk] = [0, conflictedTilesWithtk]
            for tj in cConflicts[keytk][1]:
                cConflicts[(tj, k)] = cConflicts[(tj, k)][0] - 1, cConflicts[(tj, k)][1]
            lc[("col", k)] = lc[("col", k)] + 1

    return sum(values[1] for values in lc.items())

# return heuristic value MD/3 plus linear conflicts
def heuristicValue(state):
    lc = {}
    MD = int(math.ceil(float(ManhattanDistance(state)) / 3))
    LC = (2 * linearConflict((state), lc))
    heuristic = MD + LC
    return heuristic

# check if a board configuration is present in fringe
def IsStateInClosed(current, closed):
    for item in closed:
        if item[0] == current[0]:
            return True
    return False

# returns a list of possible combinations for moving the tile Up with list of move
def MoveTileUp(puzzle, blankPosition, movesUntilNow, cost, succ):
    puzzleCopy = copy.deepcopy(puzzle)
    x = blankPosition[0][0]
    y = blankPosition[0][1]
    i = 0
    for index in range(x + 1, 4):
        movesUntilNowCopy = copy.deepcopy(movesUntilNow)
        i = i + 1
        puzzleCopy[index][y], puzzleCopy[index - 1][y] = puzzleCopy[index - 1][y], puzzleCopy[index][y]
        movesUntilNowCopy.append('U' + str(i) + str(y + 1))
        succ.append([copy.deepcopy(puzzleCopy), movesUntilNowCopy, cost + 1, cost + heuristicValue(puzzleCopy)])


# returns a list of possible combinations for moving the tile down with list of move
def MoveTileDown(puzzle, blankPosition, movesUntilNow, cost, succ):
    puzzleCopy = copy.deepcopy(puzzle)
    x = blankPosition[0][0]
    y = blankPosition[0][1]
    i = 0
    for index in range(x - 1, -1, -1):
        movesUntilNowCopy = copy.deepcopy(movesUntilNow)
        i = i + 1
        puzzleCopy[index][y], puzzleCopy[index + 1][y] = puzzleCopy[index + 1][y], puzzleCopy[index][y]
        movesUntilNowCopy.append('D' + str(i) + str(y + 1))
        succ.append([copy.deepcopy(puzzleCopy), movesUntilNowCopy, cost + 1, cost + heuristicValue(puzzleCopy)])

# return returns a list of possible combinations for moving the tile down with list of move
def MoveTileRight(puzzle, blankPosition, movesUntilNow, cost, succ):
    puzzleCopy = copy.deepcopy(puzzle)
    x = blankPosition[0][0]
    y = blankPosition[0][1]
    i = 0
    for index in range(y - 1, -1, -1):
        movesUntilNowCopy = copy.deepcopy(movesUntilNow)
        i = i + 1
        puzzleCopy[x][index], puzzleCopy[x][index + 1] = puzzleCopy[x][index + 1], puzzleCopy[x][index]
        movesUntilNowCopy.append('R' + str(i) + str(x + 1))
        succ.append([copy.deepcopy(puzzleCopy), movesUntilNowCopy, cost + 1, cost + heuristicValue(puzzleCopy)])

# returns a list of possible combinations for moving the tile Up with list of move
def MoveTileLeft(puzzle, blankPosition, movesUntilNow, cost, succ):
    puzzleCopy = copy.deepcopy(puzzle)
    x = blankPosition[0][0]
    y = blankPosition[0][1]
    i = 0
    for index in range(y + 1, 4):
        movesUntilNowCopy = copy.deepcopy(movesUntilNow)
        i = i + 1
        puzzleCopy[x][index], puzzleCopy[x][index - 1] = puzzleCopy[x][index - 1], puzzleCopy[x][index]
        movesUntilNowCopy.append('L' + str(i) + str(x + 1))
        succ.append([copy.deepcopy(puzzleCopy), movesUntilNowCopy, cost + 1, cost + heuristicValue(puzzleCopy)])

# returns a list of successors, which individually contains two list.
def successor(currentState):
    succ = []
    blankPosition = FindPositionOfBlankTile(currentState[0])
    MoveTileUp(currentState[0], blankPosition, currentState[1], currentState[2], succ)
    MoveTileDown(currentState[0], blankPosition, currentState[1], currentState[2], succ)
    MoveTileRight(currentState[0], blankPosition, currentState[1], currentState[2], succ)
    MoveTileLeft(currentState[0], blankPosition, currentState[1], currentState[2], succ)
    return succ

# returns true if current state is present in the fringe and also removes the larger cost state
def IsStateWithLargerTotalCostInFringe(current, fringe):
    for item in fringe:
        if item[0] == current[0]:
            oldCost = item[3]
            newCost = current[3]
            if oldCost > newCost:
                fringe.remove(item)
                return True
    return False

# solve using A* algorithm 3
def solve(initial_state):
    if initial_state[0] == goal_state[0]:
        return initial_state
    fringe = [initial_state]
    closed = []
    while len(fringe) > 0:
        fringe = sorted(fringe, key=itemgetter(3))
        popped_fringe = fringe.pop(0)
        if not IsStateInClosed(popped_fringe, closed) and IsParityInversionSatisfied(popped_fringe[0]):
            closed.append(popped_fringe)
            if popped_fringe[0] == goal_state[0]:
                return popped_fringe
            for s in successor(popped_fringe):
                fringe.append(s)
    return False

def IsInputValid(initialboard):
    if not CheckIfValidRowsAndColumn(initialboard):
        print "Invalid rows or col"
        return False
    if not CheckTilesInPuzzle(initialboard):
        print "Invalid tiles"
        return False
    if not CheckDuplicateTiles(initialboard):
        print "Duplicate tiles"
        return False
    if not IsParityInversionSatisfied(initialboard):
        print "Unsolvable puzzle parity not met"
        return False
    return True

filename = sys.argv[1]
with open(filename, 'r') as file:
    initial_board = []
    for line in file:
        row = []
        for col in line.strip().split(" "):
            try:
                row.append(int(col))
            except ValueError:
                print "Enter valid number"
        initial_board.append(row)
    initial_state.append(initial_board)

initial_state.append([])
initial_state.append(0)
initial_state.append(0)

if IsInputValid(initial_state[0]):
    CreateGoalStatePositionsDictionary(goal_state[0])
    solution = solve(initial_state)
    if solution == False:
        print "No solution"
    else:
        print " ".join([str(x) for x in solution[1]])
else:
    print "Not solvable"


